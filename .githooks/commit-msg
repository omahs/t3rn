# Checks that jq is usable
function check_jq_exists_and_executable {
if ! [ -x "$(command -v jq)" ]; then
  echo -e "\`commit-msg\` hook failed. Please install \`jq\`."
  exit 1
fi
}

# Check if the config file exists. If not, the hook doesn't run.
function check_config_exists {
  if [[ ! -f "$CONFIG" ]]; then
    echo -e "Config file is missing, not running commit-msg hook."
    exit 0
  fi
}

# Set the configuration from file.
function set_config {
  local_config="$PWD/.githooks/commit-msg.config.json"

  if [ -f "$local_config" ]; then
    CONFIG=$local_config
  fi
}

# Set values from config.
function set_config_values() {
  enabled=$(jq -r .enabled "$CONFIG")

  if [[ ! $enabled ]]; then
    exit 0
  fi

  revert=$(jq -r .revert "$CONFIG")
  types=($(jq -r '.types[]' "$CONFIG"))
  min_length=$(jq -r .length.min "$CONFIG")
  max_length=$(jq -r .length.max "$CONFIG")
}

# build the regex pattern based on the config file
function build_regex() {
  set_config_values

  regexp="^[.0-9]+$|"

  if $revert; then
      # regexp="${regexp}^([Rr]evert|[Mm]erge):? )?.*$|^("
      regexp="${regexp}^(revert|merge):? )?.*$|^("
  fi

  for type in "${types[@]}"
  do
    regexp="${regexp}$type|"
  done

  regexp="${regexp%|})(\(.+\))?: "

  regexp="${regexp}.{$min_length,$max_length}$"
}

# Print out an error message which an explanation.
function print_error() {
  echo "\n[ERROR] INVALID COMMIT MESSAGE: Your commit message was blocked."
  echo "------------------------"
  echo "Valid types: ${types[@]}"
  echo "First line length (in chars): max $max_length, min $min_length"
  echo "------------------------"
  echo "Please, write it again or bypass it with \`git commit --no-verify\`.\n"
}

set_config
check_config_exists
check_jq_exists_and_executable

INPUT_FILE=$1
START_LINE=`head -n1 $INPUT_FILE`

build_regex

if [[ ! $START_LINE =~ $regexp ]]; then
  # block commit if invalid
  print_error
  exit 1
fi